# Отчет по лабораторной работе 2
# Основные структуры данных. Анализ и применение

**Дата:** 2025-10-06
**Семестр:** 3 курс 1 полугодие - 5 семестр
**Группа:** ПИЖ-Б_О-23-1(2)
**Дисциплина:** Анализ сложности алгоритмов
**Студент:** Проценко Дмитрий Максимович

## Цель работы
Изучить понятие и особенности базовых абстрактных типов данных (стек, очередь, дек,
связный список) и их реализаций в Python. Научиться выбирать оптимальную структуру данных для
решения конкретной задачи, основываясь на анализе теоретической и практической сложности
операций. Получить навыки измерения производительности и применения структур данных для
решения практических задач

## Теоретическая часть
- Список (list) в Python: Реализация динамического массива. Обеспечивает амортизированное
время O(1) для добавления в конец (append). Вставка и удаление в середину имеют сложность
O(n) из-за сдвига элементов. Доступ по индексу - O(1).
- Связный список (Linked List): Абстрактная структура данных, состоящая из узлов, где каждый
узел содержит данные и ссылку на следующий элемент. Вставка и удаление в известное место
(например, начало списка) выполняются за O(1). Доступ по индексу и поиск - O(n).
- Стек (Stack): Абстрактный тип данных, работающий по принципу LIFO (Last-In-First-Out).
Основные операции: push (добавление, O(1)), pop (удаление с вершины, O(1)), peek (просмотр
вершины, O(1)). В Python может быть реализован на основе списка.
- Очередь (Queue): Абстрактный тип данных, работающий по принципу FIFO (First-In-First-Out).
Основные операции: enqueue (добавление в конец, O(1)), dequeue (удаление из начала, O(1)). В
Python для эффективной реализации используется collections.deque.
- Дек (Deque, двусторонняя очередь): Абстрактный тип данных, позволяющий добавлять и
удалять элементы как в начало, так и в конец. Все основные операции - O(1). В Python реализован
в классе collections.deque.


## Практическая часть

### Выполненные задачи
1. Реализовать класс LinkedList (связный список) для демонстрации принципов его работы.
2. Используя встроенные типы данных (list, collections.deque), проанализировать
эффективность операций, имитирующих поведение стека, очереди и дека.
3. Провести сравнительный анализ производительности операций для разных структур данных
(list vs LinkedList для вставки, list vs deque для очереди).
4. Решить 2-3 практические задачи, выбрав оптимальную структуру данных.


### Ключевые фрагменты кода
~~~ python
class Node:
    """Класс узла списка"""
    def __init__(self, data):
        self.data = data    # O(1)
        self.next = None    # O(1)

class LinkedList:
    """Класс связного списка"""
    def __init__(self):
        self.head = None    # Первый элемент списка O(1)
        self.tail = None    # Хвост списка для вставки в конце O(1)
        self.size = 0    # Размер O(1)

    def insert_at_start(self, data):
        """Добавление элемента в начало"""
        new_node = Node(data)    # Создание узла O(1) + 0(1)
        new_node.next = self.head   # Передаем ссылку на элемент, который ранее был первым 0(1)
        self.head = new_node    # Ставим элемент как голову списка 0(1)
        if self.tail is None:   # Если хвост пустой 0(1)
            self.tail = new_node   # Назначаем элемент 0(1)
        self.size += 1  # Увеличиваем поле размера 0(1)
    # Итог 0(1)

    def insert_at_end(self, data):
        """Добавление элемента в конец"""
        new_node = Node(data)   # Создание узла O(1) + 0(1)
        if not self.head:   # Если головы нет 0(1)
            self.head = self.tail = new_node    # Назначаем эелемнт как голову и хвост 0(1)
        else:   # Если голова есть 0(1)
            self.tail.next = new_node   # Назначаем хвосту ссылку на новый элемент 0(1)
            self.tail = new_node    # Новый элемент становится хвостом 0(1)
        self.size += 1 # Увеличиваем поле размера 0(1)
    # Итог 0(1)

    def delete_from_start(self):
        """Удаление элемента из начала"""
        if not self.head:   # Если головы нет 0(1)
            return None    # Выходим из функции, удалять нечего 0(1)
        data = self.head.data   # Иначе назначаем возврат головы 0(1)
        self.head = self.head.next   # Иначе назначаем возврат головы 0(1)
        if not self.head:   # Если список стал пустым O(1)
            self.tail = None    # Убираем ссылку на хвост O(1)
        self.size -= 1   # Уменьшаем счётчик размера списка O(1)
        return data    # Возвращаем последний элемент
    # Итог 0(1)

def traversal(self):
    """Обход списка"""
    result = []    # Создаём пустой список, куда будем складывать значения узлов O(1)
    current = self.head    # Начинаем обход с головы списка (первого узла) O(1)
    while current:    # Пока текущий элемент существует (не достигнут конец списка) O(n) — цикл выполняется n раз
        result.append(current.data)    # Добавляем значение текущего узла в список результатов O(1) на каждой итерации
        current = current.next    # Переходим к следующему узлу по ссылке next O(1) на каждой итерации
    return result    # Возвращаем итоговый список значений после обхода O(1)
    # Итоговая O(n)

    import matplotlib.pyplot as plt
import numpy as np
import timeit
from collections import deque
from linked_list import LinkedList


# Сравнение производительности list vs LinkedList для вставки
def test_list_insert(n=1000):
    lst = []
    for i in range(n):
        lst.insert(0, i)

def test_linkedlist_insert(n=1000):
    ll = LinkedList()
    for i in range(n):
        ll.insert_at_start(i)

# Сравнение производительности list vs deque для очереди
def test_list_queue(n=1000): # Для list
    lst = list(range(n))
    for _ in range(n):
        lst.pop(0)

def test_deque_queue(n=1000): # Для deque
    dq = deque(range(n))
    for _ in range(n):
        dq.popleft()

sizes = [100, 500, 1000, 2000, 5000]   # Разные размеры входных данных
list_insert_times = []
linkedlist_insert_times = []
list_queue_times = []
deque_queue_times = []

for size in sizes:
    print('Размер - {0}'.format(size))
    time_list = timeit.timeit("test_list_insert(size)", globals=globals(), number=10)
    time_linkedlist = timeit.timeit("test_linkedlist_insert(size)", globals=globals(), number=10)

    print("Вставка в начало")
    print(f"list.insert(0, x): {time_list:.6f} сек")
    print(f"LinkedList.insert_at_start(x): {time_linkedlist:.6f} сек\n")

    time_list_q = timeit.timeit("test_list_queue(size)", globals=globals(), number=10)
    time_deque_q = timeit.timeit("test_deque_queue(size)", globals=globals(), number=10)

    print("Очередь")
    print(f"list.pop(0): {time_list_q:.6f} сек")
    print(f"deque.popleft(): {time_deque_q:.6f} сек\n")


for n in sizes:
    # Вставка в начало
    t_list = timeit.timeit(lambda: test_list_insert(n), number=5)
    t_linked = timeit.timeit(lambda: test_linkedlist_insert(n), number=5)
    list_insert_times.append(t_list)
    linkedlist_insert_times.append(t_linked)

    # Очередь
    t_list_q = timeit.timeit(lambda: test_list_queue(n), number=5)
    t_deque_q = timeit.timeit(lambda: test_deque_queue(n), number=5)
    list_queue_times.append(t_list_q)
    deque_queue_times.append(t_deque_q)

plt.figure(figsize=(12, 5))

# list - LinkedList
plt.subplot(1, 2, 1)
plt.plot(sizes, list_insert_times, marker='o', label='list.insert(0, x)')
plt.plot(sizes, linkedlist_insert_times, marker='s', label='LinkedList.insert_at_start(x)')
plt.title("Вставка в начало: list vs LinkedList")
plt.xlabel("Количество элементов (n)")
plt.ylabel("Время выполнения (сек)")
plt.legend()
plt.grid(True)

# list - deque
plt.subplot(1, 2, 2)
plt.plot(sizes, list_queue_times, marker='o', label='list.pop(0)')
plt.plot(sizes, deque_queue_times, marker='s', label='deque.popleft()')
plt.title("Операции очереди: list vs deque")
plt.xlabel("Количество элементов (n)")
plt.ylabel("Время выполнения (сек)")
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()


from collections import deque

# Проверка сбалансированности скобок с использованием стека
def is_balanced_brackets(s):
    stack = []
    pairs = {')': '(', ']': '[', '}': '{'}
    for ch in s:
        if ch in '([{':
            stack.append(ch)
        elif ch in ')]}':
            if not stack or stack.pop() != pairs[ch]:
                return False
    return not stack

# Симуляция очереди печати (используем deque)
def print_queue_simulation(jobs):
    queue = deque(jobs)
    while queue:
        current = queue.popleft()
        print(f"Печатается задание: {current}")
    print("Все задания напечатаны.")

# Проверка палиндрома (используем deque)
def is_palindrome(s):
    dq = deque(s.lower().replace(" ", ""))
    while len(dq) > 1:
        if dq.popleft() != dq.pop():
            return False
    return True

# Пример использования
if __name__ == "__main__":
    # Проверка скобок
    expr = "{[()()]}"
    print(f"Строка {expr} сбалансирована? ->", is_balanced_brackets(expr))

    # Очередь печати
    print("\nОчередь печати:")
    print_queue_simulation(["Документ1", "Отчёт", "Скан"])

    # Палиндром
    word = "шалаш"
    print(f"\n'{word}' -> палиндром? ->", is_palindrome(word))
~~~

## Результаты выполнения

### Пример работы программы

Размер - 100
Вставка в начало
list.insert(0, x): 0.000046 сек
LinkedList.insert_at_start(x): 0.000127 сек

Очередь
list.pop(0): 0.000042 сек
deque.popleft(): 0.000023 сек

Размер - 500
Вставка в начало
list.insert(0, x): 0.000383 сек
LinkedList.insert_at_start(x): 0.000609 сек

Очередь
list.pop(0): 0.000226 сек
deque.popleft(): 0.000106 сек

Размер - 1000
Вставка в начало
list.insert(0, x): 0.001173 сек
LinkedList.insert_at_start(x): 0.001213 сек

Очередь
list.pop(0): 0.000730 сек
deque.popleft(): 0.000394 сек

Размер - 2000
Вставка в начало
list.insert(0, x): 0.004261 сек
LinkedList.insert_at_start(x): 0.002537 сек

Очередь
list.pop(0): 0.027519 сек
deque.popleft(): 0.000576 сек

Размер - 5000
Вставка в начало
list.insert(0, x): 0.024467 сек
LinkedList.insert_at_start(x): 0.006592 сек

Очередь
list.pop(0): 0.181662 сек
deque.popleft(): 0.001164 сек

## Ответы на контрольные вопросы
1. В чем ключевое отличие динамического массива (list в Python) от связного списка с точки зрения сложности операций вставки в начало и доступа по индексу? - Динамический массив (list) обеспечивает O(1) доступ по индексу, но вставка в начало требует сдвига всех элементов — O(n). Связный список, наоборот, вставляет в начало за O(1), но доступ по индексу требует прохода по элементам — O(n).

2. Объясните принцип работы стека (LIFO) и очереди (FIFO). Приведите по два примера их практического использования. - Стек (LIFO — Last In, First Out) — последний добавленный элемент извлекается первым. Очередь (FIFO — First In, First Out) — первый добавленный элемент извлекается первым. Стек: отмена действий (Undo) в редакторе, обход дерева в глубину (DFS). Очередь: очередь печати документов, обработка запросов в сервере.

3. Почему операция удаления первого элемента из списка (list) в Python имеет сложность O(n), а из дека (deque) — O(1)? - У list элементы хранятся в непрерывном блоке памяти, поэтому после удаления первого элемента все остальные сдвигаются влево — O(n). deque реализован как двусвязный список, поэтому удаление первого элемента просто меняет указатель на начало — O(1).

4. Какую структуру данных вы бы выбрали для реализации системы отмены действий (undo) в текстовом редакторе? Обоснуйте свой выбор. - Для системы отмены действий подходит стек, так как действия отменяются в обратном порядке их выполнения (LIFO). Последнее действие, выполненное пользователем, должно быть отменено первым.

5. Замеры показали, что вставка 1000 элементов в начало списка заняла значительно больше времени, чем вставка в начало вашей реализации связного списка. Объясните результаты с точки зрения асимптотической сложности. - У list.insert(0, x) сложность O(n), так как все элементы нужно сдвинуть. У LinkedList.insert_at_start(x) сложность O(1), так как добавление происходит просто изменением ссылки на новый первый элемент. Поэтому при больших данных вставка в LinkedList выполняется значительно быстрее.

## Приложения
![alt text](../docs/image.png)
